# weave_webapp/app.py

# <-- Ensure 'g' is imported
from flask import Flask, render_template, request, jsonify, g
import sqlite3
import pandas as pd
import os
from dotenv import load_dotenv

# --- Google Sheets Imports ---
import gspread
from google.oauth2.service_account import Credentials
from gspread.exceptions import APIError as GspreadAPIError  # Alias to avoid conflict


# Load environment variables from the .env file
load_dotenv()

app = Flask(__name__)

# Define the path for the SQLite database
# Using app.instance_path makes it relative to the instance folder, which is good practice
# Flask will create the 'instance' folder if it doesn't exist.
DATABASE = os.path.join(app.instance_path, 'sujets.db')
# Path to the CSV generated by the initial script
INITIAL_CSV = 'initial_sujets.csv'


# --- Google Sheets Configuration ---
SERVICE_ACCOUNT_FILE = os.getenv('GOOGLE_APPLICATION_CREDENTIALS')
GOOGLE_SHEET_ID = os.getenv('GOOGLE_SHEET_ID')
# Define the scope needed for Google Sheets (read/write)
SCOPES = ['https://www.googleapis.com/auth/spreadsheets']

# Define the name of the worksheet where enriched data will be saved
ENRICHED_SHEET_NAME = "Enriched Sujets Log"


# --- Validate essential Configuration ---
# This check happens when the app is first imported/started
if not SERVICE_ACCOUNT_FILE:
    print("Error: GOOGLE_APPLICATION_CREDENTIALS environment variable not set.")
    print("Please check your .env file and ensure it points to your service account key.")
    # In development, exiting is okay. In production, you might raise an exception or log and fail gracefully.
    exit()
# Check if the service account file actually exists at the configured path
if not os.path.exists(SERVICE_ACCOUNT_FILE):
    print(
        f"Error: Google Service Account file not found at {SERVICE_ACCOUNT_FILE}.")
    print("Please double-check the GOOGLE_APPLICATION_CREDENTIALS path in your .env file.")
    exit()

if not GOOGLE_SHEET_ID:
    print("Error: GOOGLE_SHEET_ID environment variable not set.")
    print("Please check your .env file.")
    exit()


# --- Database Helper Functions ---

def get_db():
    """Connects to the specific database or returns the existing connection."""
    # Use Flask's context-local 'g' object to store the database connection
    if 'db' not in g:  # <-- CORRECT: Access 'g' directly
        # Use the full path to the database file
        g.db = sqlite3.connect(  # <-- CORRECT: Store connection in g.db
            DATABASE,
            detect_types=sqlite3.PARSE_DECLTYPES
        )
        # sqlite3.Row provides dictionary-like access to columns by name
        g.db.row_factory = sqlite3.Row
        print("Database connection established.")
    return g.db  # <-- CORRECT: Return the connection stored in g.db


@app.teardown_appcontext
def close_db(e=None):
    """Closes the database connection at the end of the application context."""
    # Access the database connection from Flask's context-local 'g' object using pop
    # pop removes the attribute from g after retrieving it
    db = g.pop('db', None)  # <-- CORRECT: Access 'g' directly

    if db is not None:
        db.close()
        print("Database connection closed.")


def init_db():
    """Initializes the database from the initial CSV file if it doesn't exist or is empty."""
    print("Checking database status...")
    db_exists = os.path.exists(DATABASE)
    sujets_table_exists_and_not_empty = False

    if db_exists:
        try:
            conn = get_db()
            # Check if the 'sujets' table exists and has at least one row
            cursor = conn.cursor()
            # Use parameter binding for table name if it were variable, but 'sujets' is fixed here
            cursor.execute(
                "SELECT count(*) FROM sqlite_master WHERE type='table' AND name='sujets';")
            table_exists = cursor.fetchone()[0] > 0
            if table_exists:
                cursor.execute("SELECT count(*) FROM sujets;")
                row_count = cursor.fetchone()[0]
                if row_count > 0:
                    sujets_table_exists_and_not_empty = True
        except Exception as e:
            # Log error but continue, assume DB might need re-init
            print(
                f"Warning: Error checking existing database: {e}. Proceeding with initialization check.")
        finally:
            # Ensure the connection used for checking is potentially closed by teardown
            # get_db stores in g, so it will be closed when the app context used by init_db tears down
            pass  # Nothing explicit needed here thanks to teardown_appcontext

    if sujets_table_exists_and_not_empty:
        print("Database already exists and contains data. Skipping initialization.")
        return  # Don't re-initialize if it exists and contains data

    # If database doesn't exist or is empty, proceed with initialization
    print("Initializing or re-initializing database...")
    # Ensure the instance path exists where the DB file will be stored
    # This is already handled by Flask's app.instance_path property access, but explicit is safe
    os.makedirs(app.instance_path, exist_ok=True)

    try:
        # Read data from the initial CSV
        if not os.path.exists(INITIAL_CSV):
            print(
                f"Error: Initial CSV file not found at {INITIAL_CSV}. Cannot initialize database.")
            print("Please ensure initial_sujets.csv is in the correct directory.")
            # This is a fatal error for initialization, exit or raise
            exit()  # Exit the program

        df = pd.read_csv(INITIAL_CSV)

        # Add columns for manual enrichment and status
        df['user_notes'] = ''
        # Store tags as comma-separated string for simplicity in SQLite
        df['user_tags'] = ''
        # Status: 'needs_enrichment', 'enriched', 'skipped'
        df['status'] = 'needs_enrichment'

        # Rename columns to be database-friendly
        df = df.rename(columns={
            'Original Sujet': 'original_sujet',
            'Suggested Enrichment': 'ai_suggestion'
        })

        # Connect to SQLite (creates the database file if it doesn't exist)
        conn = get_db()
        # Use pandas to write the DataFrame to an SQLite table
        # Use index=True and index_label='id' to create an 'id' column from the pandas index (0, 1, 2...)
        # if_exists='replace' means if the table exists, drop it and create a new one
        df.to_sql('sujets', conn, if_exists='replace',
                  index=True, index_label='id')

        conn.commit()
        print("Database initialized successfully from CSV.")
    except Exception as e:
        print(
            f"An unexpected error occurred during database initialization: {e}")
        # If initialization fails, the app cannot run. Exit.
        exit()


# --- Google Sheets Client Helper Function ---

def get_gsheet_client():
    """Gets or creates a gspread client authenticated with the service account."""
    # Store the client in Flask's context-local 'g' object
    if 'gsheet_client' not in g:
        try:
            # Check if the service account file path exists before attempting to use it
            if not os.path.exists(SERVICE_ACCOUNT_FILE):
                print(
                    f"Error: Google Service Account file not found at {SERVICE_ACCOUNT_FILE}.")
                g.gsheet_client = None  # Store None to indicate failure
                return None  # Indicate client could not be created

            credentials = Credentials.from_service_account_file(
                SERVICE_ACCOUNT_FILE, scopes=SCOPES
            )
            g.gsheet_client = gspread.authorize(credentials)
            print("gspread client authorized for sheets.")
        except Exception as e:
            print(
                f"An unexpected error occurred during gspread client setup: {e}")
            g.gsheet_client = None  # Store None to indicate failure
            # Return None
            return None

    return g.gsheet_client


# --- App Initialization ---
# This block runs once when the app is imported/started
with app.app_context():
    # Initialize the database within the application context
    # This ensures the DB is ready when the app starts
    init_db()


# --- Flask Routes ---

@app.route('/')
def index():
    """Renders the main page."""
    return render_template('index.html')


@app.route('/get_sujet', methods=['GET'])
def get_sujet():
    """Returns the next sujet that needs enrichment from SQLite."""
    db = get_db()  # get_db() correctly accesses g.db within the request context
    sujet = db.execute(
        'SELECT id, original_sujet, ai_suggestion FROM sujets WHERE status = "needs_enrichment" ORDER BY id LIMIT 1'
    ).fetchone()

    if sujet is None:
        # No more sujets to enrich
        return jsonify({'status': 'no_more_sujets'})
    else:
        # Convert row object to dictionary for JSON response
        sujet_dict = dict(sujet)
        return jsonify({'status': 'ok', 'sujet': sujet_dict})


@app.route('/save_sujet', methods=['POST'])
def save_sujet():
    """Saves the user's enrichment to SQLite and logs to Google Sheets."""
    data = request.get_json()

    sujet_id = data.get('id')
    user_notes = data.get('user_notes', '')
    user_tags = data.get('user_tags', '')  # Should be comma-separated string

    if sujet_id is None:
        return jsonify({'status': 'error', 'message': 'Missing sujet ID'}), 400

    db = get_db()  # Gets DB connection from g.db
    gsheet_client = get_gsheet_client()  # Gets Sheets client from g.gsheet_client

    # Check if Google Sheets client was successfully created
    if gsheet_client is None:
        print("Google Sheets client is not available. Saving only to local DB.")
        # Decide how to handle: Option 1: Still save to local DB
        # Option 2: Return error and don't save anything (more atomic with Sheets)
        # Let's implement Option 1 for now, as local save is primary.
        save_to_gsheets_successful = False  # Flag to indicate Sheets save status
    else:
        save_to_gsheets_successful = True  # Assume success unless error occurs below

    # Use a transaction to ensure atomicity for SQLite updates
    # Start transaction BEFORE attempting to save to Google Sheets for better rollback logic
    db.execute("BEGIN TRANSACTION")

    try:
        # 1. Get the original and AI data for this ID from SQLite
        # Fetch from DB to ensure we have the original and AI suggestion for the sheet log
        sujet_data = db.execute(
            'SELECT original_sujet, ai_suggestion FROM sujets WHERE id = ?', (
                sujet_id,)
        ).fetchone()

        if sujet_data is None:
            db.rollback()  # Rollback the transaction as sujet not found locally
            return jsonify({'status': 'error', 'message': f'Sujet with ID {sujet_id} not found'}), 404

        original_sujet = sujet_data['original_sujet']
        ai_suggestion = sujet_data['ai_suggestion']

        # 2. Attempt to append the enriched data to the Google Sheet (Only if client available)
        if save_to_gsheets_successful:  # Only try if get_gsheet_client didn't return None
            try:
                spreadsheet = gsheet_client.open_by_key(GOOGLE_SHEET_ID)
                try:
                    # Try to open the specific worksheet by name
                    worksheet = spreadsheet.worksheet(ENRICHED_SHEET_NAME)
                except gspread.WorksheetNotFound:
                    # If the worksheet doesn't exist, create it
                    print(
                        f"Worksheet '{ENRICHED_SHEET_NAME}' not found, creating...")
                    # Create with sufficient initial rows/cols, adjust as needed
                    # Ensure service account has write access to the spreadsheet
                    try:
                        worksheet = spreadsheet.add_worksheet(
                            title=ENRICHED_SHEET_NAME, rows="100", cols="20")
                        # Add headers to the new sheet AFTER creation
                        headers = ["ID", "Original Sujet", "AI Suggestion",
                                   "User Notes", "User Tags", "Status", "Timestamp"]
                        worksheet.append_row(headers)
                        print("Created worksheet and added headers.")
                    except GspreadAPIError as e:
                        print(
                            f"Error creating worksheet '{ENRICHED_SHEET_NAME}': {e}")
                        print(
                            "Please ensure the service account has Editor access to the Google Sheet.")
                        save_to_gsheets_successful = False  # Mark Sheets save as failed
                        # Continue to save to local DB

                if save_to_gsheets_successful:  # Check again if worksheet creation failed
                    # Prepare the row data to append
                    row_data = [
                        sujet_id,
                        original_sujet,
                        ai_suggestion,
                        user_notes,
                        user_tags,
                        "enriched",  # Status for Google Sheet row
                        pd.Timestamp.now().isoformat()  # Add a timestamp
                    ]

                    # Append the row
                    worksheet.append_row(row_data)
                    print(
                        f"Saved sujet {sujet_id} data to Google Sheet '{ENRICHED_SHEET_NAME}'.")

            # Catch gspread API errors during the sheet operation (after opening spreadsheet)
            except GspreadAPIError as e:
                print(f"Google Sheets API Error saving sujet {sujet_id}: {e}")
                # Extract specific error message if available
                error_message = f"Google Sheets Error: {e.response.json().get('error', {}).get('message', str(e))}"
                # Log error but allow local save to proceed (Option 1)
                print(
                    f"Google Sheets save failed: {error_message}. Continuing to save locally.")
                save_to_gsheets_successful = False  # Mark Sheets save as failed

            except Exception as e:  # Catch any other unexpected errors during the sheet operation
                print(
                    f"An unexpected error occurred during Google Sheets save for sujet {sujet_id}: {e}")
                save_to_gsheets_successful = False  # Mark Sheets save as failed
                # Continue to save to local DB

        # 3. Update status and data in SQLite
        db.execute(
            'UPDATE sujets SET user_notes = ?, user_tags = ?, status = "enriched" WHERE id = ?',
            (user_notes, user_tags, sujet_id)
        )
        db.commit()  # Commit the SQLite transaction now that the local DB is updated
        print(f"Updated sujet {sujet_id} status to 'enriched' in SQLite.")

        # Return success even if Sheets save failed, unless we chose Option 2 above
        if save_to_gsheets_successful:
            return jsonify({'status': 'success', 'message': 'Sujet saved and logged to Google Sheets.'})
        else:
            # Still 200 OK
            return jsonify({'status': 'success', 'message': 'Sujet saved locally (Google Sheets log failed).'}), 200

    # Catch errors BEFORE the Google Sheet save attempt (e.g. DB error)
    except Exception as e:
        db.rollback()  # Ensure rollback if anything failed before Sheets write attempt
        print(
            f"An unexpected error occurred in save_sujet before Sheets write for sujet {sujet_id}: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500


@app.route('/skip_sujet', methods=['POST'])
def skip_sujet():
    """Marks a sujet as skipped in SQLite and logs to Google Sheets."""
    data = request.get_json()
    sujet_id = data.get('id')
    if sujet_id is None:
        return jsonify({'status': 'error', 'message': 'Missing sujet ID'}), 400

    db = get_db()  # Gets DB from g.db
    gsheet_client = get_gsheet_client()  # Gets Sheets client from g.gsheet_client

    if gsheet_client is None:
        print("Google Sheets client is not available. Skipping log to Google Sheets.")
        log_to_gsheets_successful = False
    else:
        log_to_gsheets_successful = True

    # Use a transaction for SQLite updates
    db.execute("BEGIN TRANSACTION")

    try:
        # 1. Get the original and AI data for this ID from SQLite (optional, but good for log)
        sujet_data = db.execute(
            'SELECT original_sujet, ai_suggestion FROM sujets WHERE id = ?', (
                sujet_id,)
        ).fetchone()

        if sujet_data is None:
            db.rollback()
            return jsonify({'status': 'error', 'message': f'Sujet with ID {sujet_id} not found'}), 404

        original_sujet = sujet_data['original_sujet']
        ai_suggestion = sujet_data['ai_suggestion']

        # 2. Attempt to append a log entry for skipping to Google Sheet
        if log_to_gsheets_successful:  # Only try if client is available
            try:
                spreadsheet = gsheet_client.open_by_key(GOOGLE_SHEET_ID)
                try:
                    worksheet = spreadsheet.worksheet(ENRICHED_SHEET_NAME)
                except gspread.WorksheetNotFound:
                    print(
                        f"Worksheet '{ENRICHED_SHEET_NAME}' not found, creating...")
                    try:
                        worksheet = spreadsheet.add_worksheet(
                            title=ENRICHED_SHEET_NAME, rows="100", cols="20")
                        headers = ["ID", "Original Sujet", "AI Suggestion",
                                   "User Notes", "User Tags", "Status", "Timestamp"]
                        worksheet.append_row(headers)
                        print("Created worksheet and added headers.")
                    except GspreadAPIError as e:
                        print(
                            f"Error creating worksheet '{ENRICHED_SHEET_NAME}': {e}")
                        print(
                            "Please ensure the service account has Editor access to the Google Sheet.")
                        log_to_gsheets_successful = False  # Mark Sheets log as failed
                        # Continue to update local DB

                if log_to_gsheets_successful:  # Check again if worksheet creation failed
                    row_data = [
                        sujet_id,
                        original_sujet,
                        ai_suggestion,
                        "",  # No user notes for skipped
                        "",  # No user tags for skipped
                        "skipped",  # Status for Google Sheet row
                        pd.Timestamp.now().isoformat()  # Add a timestamp
                    ]

                    worksheet.append_row(row_data)
                    print(
                        f"Logged skipped sujet {sujet_id} to Google Sheet '{ENRICHED_SHEET_NAME}'.")

            except GspreadAPIError as e:  # Catch gspread API errors during the sheet operation
                print(
                    f"Google Sheets API Error skipping sujet {sujet_id}: {e}")
                error_message = f"Google Sheets Error: {e.response.json().get('error', {}).get('message', str(e))}"
                # Log error but allow local save to proceed
                print(
                    f"Google Sheets log failed: {error_message}. Continuing to update locally.")
                log_to_gsheets_successful = False  # Mark Sheets log as failed

            except Exception as e:  # Catch any other unexpected errors during the sheet operation
                print(
                    f"An unexpected error occurred during Google Sheets skip log for sujet {sujet_id}: {e}")
                log_to_gsheets_successful = False  # Mark Sheets log as failed
                # Continue to update local DB

        # 3. Update status in SQLite
        db.execute(
            'UPDATE sujets SET status = "skipped" WHERE id = ?',
            (sujet_id,)  # (sujet_id,) is important for tuple with one element
        )
        db.commit()  # Commit the SQLite transaction
        print(f"Updated sujet {sujet_id} status to 'skipped' in SQLite.")

        # Return success even if Sheets log failed
        if log_to_gsheets_successful:
            return jsonify({'status': 'success', 'message': 'Sujet skipped and logged to Google Sheets.'})
        else:
            # Still 200 OK
            return jsonify({'status': 'success', 'message': 'Sujet skipped locally (Google Sheets log failed).'}), 200

    # Catch errors BEFORE the Google Sheet log attempt (e.g. DB error)
    except Exception as e:
        db.rollback()  # Ensure rollback if anything failed before Sheets write attempt
        print(
            f"An unexpected error occurred in skip_sujet before Sheets write for sujet {sujet_id}: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500


# --- To run this app (for development) ---
# Make sure you are in the 'weave_webapp' directory with your venv activated.
# Ensure you have created an 'instance' folder manually.
# Ensure you have initial_sujets.csv, app.py, index.html, style.css, script.js, .env, .gitignore in place.
# Ensure your .env file has GOOGLE_APPLICATION_CREDENTIALS and GOOGLE_SHEET_ID pointing correctly.
# Ensure your service account has Editor access on the Google Sheet.
# Set the FLASK_APP environment variable:
# On macOS/Linux: export FLASK_APP=app.py
# On Windows: set FLASK_APP=app.py
# Run the Flask development server:
# flask run

# Optional: Uncomment the following lines to run with debug mode if running this file directly
# This is an alternative to 'flask run' but 'flask run' is generally preferred during development
# if __name__ == '__main__':
#     # Ensure instance path exists if running directly this way
#     os.makedirs(app.instance_path, exist_ok=True)
#     # Initialize DB if needed
#     with app.app_context():
#          init_db()
#     app.run(debug=True)
